<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 수학 튜터 (Vue 3)</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- MathJax CDN: LaTeX 수식 렌더링을 위함 -->
    <script>
        MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']], // 인라인 수식 $...$
                displayMath: [['$$', '$$'], ['\\[', '\\]']] // 디스플레이 수식 $$...$$
            },
            svg: {
                fontCache: 'global'
            },
            startup: {
                ready: () => {
                    MathJax.startup.defaultReady();
                    // Vue 앱이 마운트된 후 MathJax를 실행할 수 있도록 이벤트를 생성합니다.
                    document.dispatchEvent(new Event('MathJaxReady'));
                }
            }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
            src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    <style>
        /* 기본 폰트 설정 */
        body {
            font-family: 'Inter', sans-serif;
        }
        /* 캔버스 스타일 */
        #handwriting-canvas {
            touch-action: none; /* 모바일에서 그릴 때 화면 스크롤 방지 */
            cursor: crosshair; /* 그리기 커서 */
        }
        /* 선택된 툴 버튼 스타일 */
        .tool-btn.active {
            background-color: #2563eb; /* bg-blue-600 */
            color: white;
            border-color: #2563eb; /* border-blue-600 */
        }
        /* Tailwind CSS v-cloak 대체 스타일 */
        [v-cloak] {
            display: none;
        }
        /* 로딩 스피너 스타일 */
        .spinner {
            border-top-color: #3498db;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            to {
                transform: rotate(360deg);
            }
        }
        /* 객관식 보기 라디오 버튼 숨기기 */
        .choice-radio {
            display: none;
        }
        
        /* [수정] 객관식 보기 커스텀 스타일 */
        .choice-label {
            display: flex; /* 한 줄 정렬을 위해 flex 사용 */
            align-items: center; /* 세로 중앙 정렬 */
            padding: 1rem;
            border: 1px solid #d1d5db; /* border-gray-300 */
            border-radius: 0.5rem; /* rounded-lg */
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .choice-label:hover {
            border-color: #3b82f6; /* border-blue-500 */
        }
        
        /* [추가] 객관식 보기 번호 (원형) */
        .choice-number {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.75rem; /* 28px */
            height: 1.75rem; /* 28px */
            border-radius: 9999px; /* full circle */
            background-color: #e5e7eb; /* bg-gray-200 */
            color: #374151; /* text-gray-700 */
            font-weight: 600; /* semibold */
            margin-right: 0.75rem; /* mr-3 */
            flex-shrink: 0; /* 크기 고정 (줄바꿈 방지) */
            transition: all 0.2s ease;
        }
        
        /* [수정] 선택된 객관식 보기 스타일 */
        .choice-radio:checked + .choice-label {
            border-color: #2563eb; /* border-blue-600 */
            background-color: #eff6ff; /* bg-blue-50 */
            border-width: 2px;
        }
        /* [수정] 선택 시 원형 번호 스타일 변경 */
        .choice-radio:checked + .choice-label .choice-number {
            background-color: #2563eb; /* bg-blue-600 */
            color: white;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen p-4 md:p-8">

<div id="app" v-cloak class="max-w-7xl mx-auto bg-white p-6 md:p-10 rounded-2xl shadow-lg">

    <h1 class="text-3xl md:text-4xl font-bold text-center text-blue-700 mb-8">AI 수학 튜터</h1>

    <!-- 1. API 키 입력 및 문제 설정 -->
    <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
        <!-- API 키 입력 -->
        <div class="md:col-span-1">
            <label for="apiKey" class="block text-sm font-medium text-gray-700 mb-2">Google AI API Key</label>
            <input type="password" id="apiKey" v-model="apiKey" placeholder="AI-..."
                   class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition"
                   autocomplete="current-password">
        </div>

        <!-- 문제 유형 선택 -->
        <div class="md:col-span-1">
            <label for="problemType" class="block text-sm font-medium text-gray-700 mb-2">문제 유형 (성취 기준)</label>
            <select id="problemType" v-model="problemType"
                    class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition bg-white">
                <optgroup label="(2) 집합과 명제">
                    <option value="[10공수2-02-01] 집합의 개념을 이해하고, 집합을 표현할 수 있다.">[10공수2-02-01] 집합의 개념과 표현</option>
                    <option value="[10공수2-02-02] 두 집합 사이의 포함관계를 판단할 수 있다.">[10공수2-02-02] 집합의 포함관계</option>
                    <option value="[10공수2-02-03] 집합의 연산을 수행하고, 벤 다이어그램을 이용하여 나타낼 수 있다.">[10공수2-02-03] 집합의 연산 (벤 다이어그램)</option>
                    <option value="[10공수2-02-04] 명제와 조건의 뜻을 알고, ‘모든’, ‘어떤’을 포함한 명제를 이해하고 설명할 수 있다.">[10공수2-02-04] 명제와 조건 (모든, 어떤)</option>
                    <option value="[10공수2-02-05] 명제의 역과 대우를 이해하고 설명할 수 있다.">[10공수2-02-05] 명제의 역과 대우</option>
                    <option value="[10공수2-02-06] 충분조건과 필요조건을 이해하고 판단할 수 있다.">[10공수2-02-06] 충분조건과 필요조건</option>
                    <option value="[10공수2-02-07] 대우를 이용한 증명법과 귀류법을 이해하고 관련된 명제를 증명할 수 있다.">[10공수2-02-07] 증명법 (대우, 귀류법)</option>
                    <option value="[10공수2-02-08] 절대부등식의 뜻을 알고, 간단한 절대부등식을 증명할 수 있다.">[10공수2-02-08] 절대부등식</option>
                </optgroup>
                <optgroup label="(3) 함수와 그래프">
                    <option value="[10공수2-03-01] 함수의 개념을 설명하고, 그 그래프를 이해한다.">[10공수2-03-01] 함수의 개념과 그래프</option>
                    <option value="[10공수2-03-02] 함수의 합성을 설명하고, 합성함수를 구할 수 있다.">[10공수2-03-02] 합성함수</option>
                    <option value="[10공수2-03-03] 역함수의 개념을 설명하고, 역함수를 구할 수 있다.">[10공수2-03-03] 역함수</option>
                    <option value="[10공수2-03-04] 유리함수 y = (ax+b)/(cx+d) 의 그래프를 그릴 수 있고, 그 그래프의 성질을 탐구할 수 있다.">[10공수2-03-04] 유리함수와 그래프</option>
                    <option value="[10공수2-03-05] 무리함수 y = sqrt(ax+b)+c 의 그래프를 그릴 수 있고, 그 그래프의 성질을 탐구할 수 있다.">[10공수2-03-05] 무리함수와 그래프</option>
                </optgroup>
            </select>
        </div>

        <!-- 난이도 선택 -->
        <div class="md:col-span-1">
            <label for="difficulty" class="block text-sm font-medium text-gray-700 mb-2">난이도 (1~5)</label>
            <select id="difficulty" v-model.number="difficultyLevel"
                    class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition bg-white">
                <option value="1">1 (매우 쉬움)</option>
                <option value="2">2 (쉬움)</option>
                <option value="3">3 (보통)</option>
                <option value="4">4 (어려움)</option>
                <option value="5">5 (매우 어려움)</option>
            </select>
        </div>
    </div>

    <!-- 새로운 문제 받기 버튼 -->
    <button @click="getMathProblem" :disabled="isLoadingProblem || !apiKey"
            class="w-full mb-8 px-6 py-3 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition duration-300 ease-in-out flex items-center justify-center">
        <svg v-if="isLoadingProblem" class="spinner w-5 h-5 mr-3" viewBox="0 0 50 50">
            <circle class="opacity-25" cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4"></circle>
            <circle class="opacity-75" cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4"
                    stroke-dasharray="31.41592653589793 31.41592653589793"
                    stroke-dashoffset="31.41592653589793"></circle>
        </svg>
        <span>{{ isLoadingProblem ? '문제 생성 중...' : '새로운 문제 받기' }}</span>
    </button>

    <!-- 오류 메시지 표시 -->
    <div v-if="errorMessage" class="mb-4 p-4 bg-red-100 border border-red-400 text-red-700 rounded-lg" role="alert">
        <span class="font-bold">오류 발생:</span>
        <span class="block sm:inline">{{ errorMessage }}</span>
    </div>

    <!-- 1. 오늘의 문제 -->
    <!-- [수정] v-if를 내부로 이동시켜, 섹션 자체는 항상 보이도록 함 -->
    <div class="mb-8 p-6 bg-gray-50 rounded-lg border border-gray-200 min-h-[100px]">
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">1. 오늘의 문제</h2>
        <!-- 문제가 있을 때만 내용을 표시 -->
        <div v-if="mathProblem">
            <div v-html="mathProblem.problemText" class="text-base text-gray-700 leading-relaxed break-words"></div>
            <!-- 5지선다형 객관식 보기 -->
            <div class="mt-6 space-y-3" v-if="mathProblem.options && mathProblem.options.length === 5">
                <h3 class="text-lg font-semibold text-gray-700 mb-2">객관식 선택:</h3>
                <div v-for="(option, index) in mathProblem.options" :key="index">
                    <input type="radio" :id="'choice-' + index" :value="index" v-model="selectedOptionIndex" class="choice-radio">
                    <label :for="'choice-' + index" class="choice-label">
                        <!-- [수정] 원형 번호 추가 -->
                        <span class="choice-number">{{ index + 1 }}</span>
                        <span v-html="option" class="break-words min-w-0"></span>
                    </label>
                </div>
            </div>
        </div>
        <!-- 문제가 없을 때 안내 메시지 -->
        <div v-else class="text-gray-500">
            '새로운 문제 받기' 버튼을 눌러주세요.
        </div>
    </div>

    <!-- 2. 답안 필기 -->
    <!-- [수정] v-if="mathProblem" 제거. 항상 보이도록 함. -->
    <div class="mb-8">
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">2. 답안 필기</h2>
        <!-- 캔버스 도구 모음 -->
        <div class="flex flex-wrap gap-2 mb-3 p-3 bg-gray-100 rounded-lg">
            <button @click="setTool('pen', 'black')" :class="{'active': currentTool === 'pen' && penColor === 'black'}"
                    class="tool-btn px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 transition">
                펜 (검정)
            </button>
            <button @click="setTool('pen', 'red')" :class="{'active': currentTool === 'pen' && penColor === 'red'}"
                    class="tool-btn px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 transition">
                펜 (빨강)
            </button>
            <button @click="setTool('eraser')" :class="{'active': currentTool === 'eraser'}"
                    class="tool-btn px-4 py-2 bg-white border border-gray-300 rounded-lg shadow-sm hover:bg-gray-50 transition">
                지우개
            </button>
            <button @click="clearCanvas"
                    class="px-4 py-2 bg-red-500 text-white rounded-lg shadow-sm hover:bg-red-600 transition ml-auto">
                전체 삭제
            </button>
            <button @click="extendCanvas"
                    class="px-4 py-2 bg-green-500 text-white rounded-lg shadow-sm hover:bg-green-600 transition">
                필기 영역 늘리기
            </button>
        </div>

        <canvas id="handwriting-canvas" ref="canvas" class="w-full bg-white border-2 border-gray-300 rounded-lg shadow-inner"></canvas>
    </div>

    <!-- 3. AI 피드백 -->
    <!-- [수정] v-if="mathProblem" 제거. 항상 보이도록 함. -->
    <div class="mb-8">
        <!-- 피드백 받기 버튼 -->
        <!-- [수정] !mathProblem 일 때도 disabled 되도록 조건 추가 -->
        <button @click="getFeedback" :disabled="isLoadingFeedback || !apiKey || !mathProblem"
                class="w-full px-6 py-3 bg-indigo-600 text-white font-semibold rounded-lg shadow-md hover:bg-indigo-700 disabled:bg-gray-400 disabled:cursor-not-allowed transition duration-300 ease-in-out flex items-center justify-center">
            <svg v-if="isLoadingFeedback" class="spinner w-5 h-5 mr-3" viewBox="0 0 50 50">
                <circle class="opacity-25" cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4"></circle>
                <circle class="opacity-75" cx="25" cy="25" r="20" fill="none" stroke="currentColor" stroke-width="4"
                        stroke-dasharray="31.41592653589793 31.41592653589793"
                        stroke-dashoffset="31.41592653589793"></circle>
            </svg>
            <span v-if="!mathProblem">문제를 먼저 받아주세요</span>
            <span v-else-if="isLoadingFeedback">AI가 채점 중입니다...</span>
            <span v-else>피드백 받기</span>
        </button>

        <!-- CSV 내보내기 버튼 -->
        <div class="mt-4 text-center">
            <button @click="exportToCSV" :disabled="analysisData.length === 0"
                    class="px-4 py-2 bg-gray-600 text-white text-sm font-medium rounded-lg shadow-sm hover:bg-gray-700 disabled:bg-gray-300 transition">
                분석 데이터 내보내기 (CSV)
            </button>
            <p class="text-xs text-gray-500 mt-1">
                현재까지 저장된 풀이 기록: {{ analysisData.length }}개
            </p>
        </div>

        <!-- 피드백 결과 표시 -->
        <div v-if="feedback" class="mt-8 p-6 bg-blue-50 border border-blue-200 rounded-lg">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">3. AI 튜터의 피드백</h2>
            <div v-html="feedback" class="text-base text-gray-700 leading-relaxed break-words"></div>
        </div>
    </div>


</div> <!-- end of #app -->

<script type="module">
    // Vue 3 Composition API를 사용합니다.
    const { createApp, ref, onMounted, watch, nextTick } = Vue;

    createApp({
        setup() {
            // --- 상태 변수 정의 (ref) ---

            // API 및 로딩 상태
            const apiKey = ref(localStorage.getItem('geminiApiKey') || ''); // localStorage에서 로드
            const isLoadingProblem = ref(false); 
            const isLoadingFeedback = ref(false); 
            const errorMessage = ref(''); 

            // 문제 관련 상태
            const problemType = ref('[10공수2-02-01] 집합의 개념을 이해하고, 집합을 표현할 수 있다.');
            const difficultyLevel = ref(3); 
            const mathProblem = ref(null); // AI가 생성한 문제 객체
            const selectedOptionIndex = ref(null); // 사용자가 선택한 객관식 답

            // 캔버스 관련 상태
            const canvas = ref(null); // 캔버스 DOM 엘리먼트
            const ctx = ref(null); // 캔버스 2D 컨텍스트
            const isDrawing = ref(false); 
            const currentTool = ref('pen'); 
            const penColor = ref('black'); 
            const penWidth = ref(3); 
            const eraserWidth = ref(10); 

            // 피드백 및 분석 상태
            const feedback = ref(''); // AI 피드백 텍스트 (HTML)
            const analysisData = ref([]); // CSV 내보내기를 위한 데이터 누적 배열

            // --- API 호출 관련 ---

            const API_URL = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";

            /**
             * AI에게 5지선다형 객관식 문제를 JSON 형식으로 요청합니다.
             */
            async function getMathProblem() {
                if (!apiKey.value) {
                    errorMessage.value = 'API 키를 입력해주세요.';
                    return;
                }
                isLoadingProblem.value = true;
                errorMessage.value = '';
                mathProblem.value = null; // [중요] 이전 문제 초기화
                feedback.value = '';
                selectedOptionIndex.value = null; // 선택 초기화
                clearCanvas(); // [추가] 새 문제 받을 때 캔버스 지우기

                const systemInstruction = {
                    parts: [{
                        // [수정] 불필요한 줄바꿈 자제 요청
                        text: `당신은 유능한 한국어 수학 교사입니다.
1. 사용자가 요청한 '성취 기준'과 '난이도'에 맞는 수학 문제를 출제해야 합니다.
2. 문제는 반드시 LaTeX 수식을 포함해야 합니다. (예: $f(x) = x^2$)
3. 문제는 5지선다형 객관식이어야 하며, 1개의 정답과 4개의 매력적인 오답을 포함해야 합니다.
4. 모든 텍스트는 한국어로 작성해야 합니다.
5. [중요] 문제 본문(problemText)은 문단 구분이 필요한 경우를 제외하고는, 불필요한 줄바꿈 없이 자연스러운 문장으로 생성해야 합니다.
6. [중요] 5지선다형 보기는 수식이나 답 그 자체만 제시하세요. (예: '$x > 1$'). '명제:', '답:' 같은 불필요한 접두사를 붙이지 마세요.`
                    }]
                };

                const userQuery = {
                    parts: [{
                        text: `성취 기준: ${problemType.value}\n난이도: ${difficultyLevel.value} (1~5 스케일)`
                    }]
                };

                // AI에게 요청할 payload. JSON 응답을 요청합니다.
                const payload = {
                    contents: [userQuery],
                    systemInstruction: systemInstruction,
                    generationConfig: {
                        responseMimeType: "application/json",
                        responseSchema: {
                            type: "OBJECT",
                            properties: {
                                "problemText": { "type": "STRING", "description": "LaTeX를 포함한 문제 본문입니다." },
                                "options": {
                                    "type": "ARRAY",
                                    "description": "5개의 선택지. 각 선택지는 LaTeX를 포함할 수 있습니다.",
                                    "items": { "type": "STRING", "description": "선택지 텍스트 또는 수식 그 자체. 접두사 금지." },
                                    "minItems": 5,
                                    "maxItems": 5
                                },
                                "answerIndex": { "type": "INTEGER", "description": "정답 선택지의 인덱스 (0~4)" },
                                "answerExplanation": { "type": "STRING", "description": "정답에 대한 간략한 해설 (LaTeX 포함 가능)" }
                            },
                            required: ["problemText", "options", "answerIndex", "answerExplanation"]
                        }
                    }
                };

                try {
                    const response = await fetchWithRetry(API_URL + apiKey.value, payload);
                    const result = await response.json();

                    if (result.candidates && result.candidates[0].content) {
                        const jsonText = result.candidates[0].content.parts[0].text;
                        mathProblem.value = JSON.parse(jsonText); // 파싱된 JSON 객체를 상태에 저장

                        // [수정] 캔버스 초기화 로직을 onMounted로 이동시켰으므로 여기서는 호출 X
                        
                    } else {
                        throw new Error(result.error ? result.error.message : 'AI가 유효한 응답을 생성하지 못했습니다.');
                    }
                } catch (error) {
                    console.error('Error getting math problem:', error);
                    errorMessage.value = `문제 생성 중 오류가 발생했습니다: ${error.message}`;
                } finally {
                    isLoadingProblem.value = false;
                }
            }

            /**
             * AI에게 필기 이미지와 선택한 답을 보내고 피드백을 요청합니다.
             * ('모름' 버그 수정을 위한 프롬프트 포함)
             */
            async function getFeedback() {
                // [수정] 캔버스 컨텍스트 및 mathProblem 존재 여부 확인
                if (!apiKey.value || !mathProblem.value || !ctx.value) {
                    errorMessage.value = '먼저 문제를 받거나 캔버스가 준비되었는지 확인해주세요.';
                    return;
                }
                isLoadingFeedback.value = true;
                errorMessage.value = '';
                feedback.value = '';

                // 캔버스 이미지를 Base64로 인코딩
                const canvasImageBase64 = canvas.value.toDataURL('image/png').split(',')[1];
                const selectedAnswer = selectedOptionIndex.value !== null ? mathProblem.value.options[selectedOptionIndex.value] : "선택 안함";

                // [수정] "모름" 버그를 잡기 위한 강력한 시스템 지시어
                const systemInstruction = {
                    parts: [{
                        text: `당신은 학생의 풀이를 분석하는 엄격하고 친절한 한국어 수학 튜터입니다.
제시된 문제, 학생이 선택한 객관식 답, 학생이 캔버스에 쓴 손글씨 풀이를 분석해야 합니다.

**[채점 원칙]**
1.  **[1단계: 손글씨 인식]** 먼저, 학생의 손글씨 이미지에 어떤 내용이 있는지 정확히 인식합니다. (예: "2x+1", "모름", "포기", "그림", "빈 칸" 등)
2.  **[2단계: 상황 판단]**
    * **Case A (풀이 없음):** 만약 학생이 '모름', '포기'라고 썼거나, 의미 없는 낙서를 했거나, 캔버스가 거의 비어있다면, **절대로 긍정적인 점수나 '잘했다'는 말을 해서는 안 됩니다.**
    * **Case B (풀이 있음):** 만약 학생이 수학 풀이 과정을 작성했다면, 3단계 채점을 시작합니다.
3.  **[3단계: 피드백 생성]**
    * **Case A (풀이 없음) 응답:** "문제를 풀기 어려우셨군요." 또는 "답안이 작성되지 않았습니다."라고 말하고, **점수를 주지 마세요.** 대신 문제 풀이에 필요한 **핵심 힌트**를 제공하세요. (예: "이 문제는 $f(g(x))$를 먼저 계산해야 합니다.")
    * **Case B (풀이 있음) 응답:**
        1.  학생이 선택한 **객관식 답**이 정답(정답 인덱스: ${mathProblem.value.answerIndex})인지 먼저 확인하고 맞았는지 틀렸는지 언급하세요.
        2.  학생의 **손글씨 풀이 과정**을 단계별로 분석하고, 논리적인 오류나 계산 실수를 찾아내세요.
        3.  모든 것을 종합하여 **점수(예: 5/5점)**와 함께 상세하고 친절한 피드백을 주세요.
        4.  모든 피드백에는 **LaTeX 수식**을 적극적으로 사용하세요.`
                    }]
                };

                // AI에게 보낼 내용 (멀티모달)
                const contents = [
                    {
                        parts: [
                            { text: `[문제]\n${mathProblem.value.problemText}` },
                            { text: `[객관식 보기]\n${mathProblem.value.options.join('\n')}` },
                            { text: `[정답]\n${mathProblem.value.answerIndex}번 (${mathProblem.value.options[mathProblem.value.answerIndex]})` },
                            { text: `[학생이 선택한 답]\n${selectedOptionIndex.value !== null ? (selectedOptionIndex.value + '번 (' + selectedAnswer + ')') : '선택 안함'}` },
                            { text: "\n[학생의 손글씨 풀이 이미지]:" },
                            {
                                inlineData: {
                                    mimeType: "image/png",
                                    data: canvasImageBase64
                                }
                            }
                        ]
                    }
                ];

                const payload = { contents, systemInstruction };

                try {
                    const response = await fetchWithRetry(API_URL + apiKey.value, payload);
                    const result = await response.json();

                    if (result.candidates && result.candidates[0].content) {
                        let feedbackText = result.candidates[0].content.parts[0].text;
                        // 마크다운을 HTML로 변환
                        feedbackText = feedbackText
                            .replace(/\*\*(.*?)\*\*/g, '<strong>$1</strong>') 
                            .replace(/\*(.*?)\*/g, '<em>$1</em>')       
                            .replace(/\n/g, '<br>');                      
                        feedback.value = feedbackText;

                        // CSV 저장을 위해 데이터 누적
                        saveAnalysisData(feedbackText);

                    } else {
                        throw new Error(result.error ? result.error.message : 'AI가 유효한 피드백을 생성하지 못했습니다.');
                    }
                } catch (error) {
                    console.error('Error getting feedback:', error);
                    errorMessage.value = `피드백 생성 중 오류가 발생했습니다: ${error.message}`;
                } finally {
                    isLoadingFeedback.value = false;
                }
            }

            /**
             * 분석용 데이터를 객체로 저장합니다.
             */
            function saveAnalysisData(feedbackText) {
                const canvasImageBase64 = canvas.value ? canvas.value.toDataURL('image/png') : 'N/A';

                const dataEntry = {
                    timestamp: new Date().toISOString(),
                    problemType: problemType.value,
                    difficulty: difficultyLevel.value,
                    problemText: mathProblem.value.problemText,
                    options: JSON.stringify(mathProblem.value.options), 
                    answerIndex: mathProblem.value.answerIndex,
                    answerExplanation: mathProblem.value.answerExplanation,
                    selectedOptionIndex: selectedOptionIndex.value,
                    selectedOptionText: selectedOptionIndex.value !== null ? mathProblem.value.options[selectedOptionIndex.value] : "N/A",
                    canvasImageBase64: canvasImageBase64, // 풀이 이미지 저장
                    aiFeedback: feedbackText.replace(/<br>/g, '\n').replace(/<[^>]+>/g, '') // HTML 태그 제거
                };
                analysisData.value.push(dataEntry);
            }

            /**
             * 누적된 분석 데이터를 CSV 파일로 내보냅니다.
             */
            function exportToCSV() {
                if (analysisData.value.length === 0) {
                    errorMessage.value = '내보낼 데이터가 없습니다.'; 
                    return;
                }

                const headers = Object.keys(analysisData.value[0]);
                let csvContent = "data:text/csv;charset=utf-8,\uFEFF"; // \uFEFF: UTF-8 BOM (Excel 한글 깨짐 방지)
                csvContent += headers.join(",") + "\r\n";

                analysisData.value.forEach(row => {
                    const values = headers.map(header => {
                        let value = row[header];
                        
                        // 캔버스 이미지는 CSV에 포함하지 않음 (텍스트로 대체)
                        if (header === 'canvasImageBase64') {
                            return '"IMAGE_DATA_REDACTED"';
                        }
                        
                        if (typeof value === 'string') {
                            value = value.replace(/"/g, '""'); 
                            value = `"${value}"`; 
                        } else if (value === null || value === undefined) {
                            value = '""';
                        }
                        return String(value); 
                    });
                    csvContent += values.join(",") + "\r\n";
                });

                // 파일 다운로드
                const encodedUri = encodeURI(csvContent);
                const link = document.createElement("a");
                link.setAttribute("href", encodedUri);
                link.setAttribute("download", "math_tutor_analysis.csv");
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
            }

            /**
             * API 요청 재시도 로직 (Exponential Backoff)
             */
            async function fetchWithRetry(url, payload, retries = 3) {
                let attempt = 0;
                while (attempt < retries) {
                    try {
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        if (!response.ok) {
                            if (response.status === 429 || response.status >= 500) {
                                throw new Error(`Server responded with status ${response.status}`);
                            }
                            return response;
                        }
                        return response;
                    } catch (error) {
                        attempt++;
                        if (attempt >= retries) {
                            throw error; 
                        }
                        const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000;
                        await new Promise(resolve => setTimeout(resolve, delay));
                    }
                }
            }

            // --- 캔버스 관련 함수 ---

            /**
             * [수정] 캔버스 초기화 (컴포넌트 마운트 시)
             */
            function initializeCanvas() {
                const canvasEl = canvas.value;
                if (!canvasEl) {
                    console.error("InitializeCanvas: 캔버스 요소를 찾을 수 없습니다.");
                    return;
                }

                ctx.value = canvasEl.getContext('2d');
                if (!ctx.value) {
                     console.error("InitializeCanvas: 2D 컨텍스트를 가져올 수 없습니다.");
                    return;
                }

                // 반응형 캔버스 크기 설정
                const dpi = window.devicePixelRatio || 1;
                const rect = canvasEl.getBoundingClientRect();
                
                canvasEl.width = rect.width * dpi;
                // [수정] 초기 높이 설정
                if (!canvasEl.style.height) {
                     canvasEl.style.height = '400px'; // 기본 높이
                }
                canvasEl.height = parseInt(canvasEl.style.height, 10) * dpi;

                ctx.value.scale(dpi, dpi); 

                // 기본 그리기 설정
                ctx.value.strokeStyle = penColor.value;
                ctx.value.lineWidth = penWidth.value;
                ctx.value.lineCap = 'round';
                ctx.value.lineJoin = 'round';

                // 캔버스 배경을 흰색으로 채우기
                fillWhiteBackground();

                // 이벤트 리스너 등록
                canvasEl.addEventListener('mousedown', startDrawing);
                canvasEl.addEventListener('mousemove', draw);
                canvasEl.addEventListener('mouseup', stopDrawing);
                canvasEl.addEventListener('mouseout', stopDrawing);

                canvasEl.addEventListener('touchstart', startDrawing);
                canvasEl.addEventListener('touchmove', draw);
                canvasEl.addEventListener('touchend', stopDrawing);
            }

            /**
             * 캔버스 배경을 흰색으로 채웁니다.
             */
            function fillWhiteBackground() {
                if (!ctx.value) return; 
                const dpi = window.devicePixelRatio || 1;
                ctx.value.save();
                ctx.value.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.value.fillStyle = 'white';
                ctx.value.fillRect(0, 0, canvas.value.width, canvas.value.height);
                ctx.value.restore();
                ctx.value.scale(dpi, dpi); 
            }

            /**
             * 그리기 시작 (이벤트 핸들러)
             */
            function startDrawing(e) {
                if (!ctx.value) return;
                e.preventDefault();
                isDrawing.value = true;
                const pos = getEventPosition(e);
                ctx.value.beginPath();
                ctx.value.moveTo(pos.x, pos.y);
            }

            /**
             * 그리기 (이벤트 핸들러)
             */
            function draw(e) {
                if (!isDrawing.value || !ctx.value) return;
                e.preventDefault();
                const pos = getEventPosition(e);
                ctx.value.lineTo(pos.x, pos.y);
                ctx.value.stroke();
            }

            /**
             * 그리기 중지 (이벤트 핸들러)
             */
            function stopDrawing() {
                if (isDrawing.value && ctx.value) {
                    ctx.value.closePath();
                    isDrawing.value = false;
                }
            }

            /**
             * 이벤트에서 캔버스 상의 좌표를 가져옵니다.
             */
            function getEventPosition(e) {
                const rect = canvas.value.getBoundingClientRect();
                let x, y;

                if (e.touches && e.touches.length > 0) {
                    x = e.touches[0].clientX - rect.left;
                    y = e.touches[0].clientY - rect.top;
                } else {
                    x = e.clientX - rect.left;
                    y = e.clientY - rect.top;
                }
                
                return { x, y };
            }

            /**
             * 캔버스 전체 삭제
             */
            function clearCanvas() {
                if (!ctx.value || !canvas.value) return;
                const dpi = window.devicePixelRatio || 1;
                ctx.value.save();
                ctx.value.setTransform(1, 0, 0, 1, 0, 0); 
                ctx.value.clearRect(0, 0, canvas.value.width, canvas.value.height);
                ctx.value.restore();
                ctx.value.scale(dpi, dpi); 
                fillWhiteBackground(); // 다시 흰색 배경으로
            }

            /**
             * 캔버스 높이 확장 (기존 그림 유지)
             */
            function extendCanvas() {
                const canvasEl = canvas.value;
                if (!ctx.value || !canvasEl) return;
                
                const dpi = window.devicePixelRatio || 1;
                
                // 1. 현재 캔버스 내용을 이미지로 저장
                const imageData = ctx.value.getImageData(0, 0, canvasEl.width / dpi, canvasEl.height / dpi);
                
                // 2. 캔버스 높이 늘리기
                const newHeight = parseInt(canvasEl.style.height, 10) + 200; // 200px 추가
                canvasEl.style.height = `${newHeight}px`;
                canvasEl.height = newHeight * dpi;

                // 3. DPI 스케일링 및 컨텍스트 설정 복원
                ctx.value.scale(dpi, dpi);
                setTool(currentTool.value, penColor.value); 
                
                // 4. 배경 다시 칠하기 및 이미지 복원
                fillWhiteBackground();
                ctx.value.putImageData(imageData, 0, 0);
            }

            /**
             * 그리기 도구 설정 (펜 또는 지우개)
             */
            function setTool(tool, color) {
                if (!ctx.value) return; 
                currentTool.value = tool;
                if (tool === 'pen') {
                    penColor.value = color || penColor.value; 
                    ctx.value.globalCompositeOperation = 'source-over'; 
                    ctx.value.strokeStyle = penColor.value;
                    ctx.value.lineWidth = penWidth.value;
                } else if (tool === 'eraser') {
                    ctx.value.globalCompositeOperation = 'destination-out'; // 지우개 모드
                    ctx.value.lineWidth = eraserWidth.value;
                }
            }


            // --- Vue 라이프사이클 및 감시자 (Watchers) ---

            /**
             * [수정] Vue 앱이 마운트된 후에 실행됩니다.
             */
            onMounted(() => {
                // 페이지 로드 시 캔버스를 즉시 초기화합니다.
                initializeCanvas();
                
                document.addEventListener('MathJaxReady', () => {
                    // MathJax 준비 완료
                });
            });

            /**
             * API 키가 변경될 때마다 localStorage에 저장합니다.
             */
            watch(apiKey, (newKey) => {
                localStorage.setItem('geminiApiKey', newKey);
            });

            /**
             * `mathProblem` 또는 `feedback` 상태가 변경될 때마다 MathJax를 실행합니다.
             */
            watch([mathProblem, feedback], () => {
                nextTick(() => {
                    if (window.MathJax && typeof window.MathJax.typesetPromise === 'function') {
                        window.MathJax.typesetPromise().catch((err) => {
                            console.error('MathJax 렌더링 오류:', err);
                        });
                    }
                });
            });

            // 템플릿(HTML)에서 사용할 변수 및 함수 반환
            return {
                // 상태
                apiKey,
                isLoadingProblem,
                isLoadingFeedback,
                errorMessage,
                problemType,
                difficultyLevel,
                mathProblem,
                selectedOptionIndex,
                canvas, // ref
                feedback,
                currentTool,
                penColor,
                analysisData,

                // 함수
                getMathProblem,
                getFeedback,
                setTool,
                clearCanvas,
                extendCanvas,
                exportToCSV
            };
        }
    }).mount('#app'); // #app 엘리먼트에 Vue 앱을 마운트합니다.

</script>
</body>
</html>
