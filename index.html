<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 수학 문제 풀이</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Vue 3 CDN -->
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <!-- Inter 폰트 (Tailwind 기본 폰트) -->
    <link rel="stylesheet" href="https://rsms.me/inter/inter.css">
    
    <!-- MathJax (수학 수식 렌더링) CDN 추가 -->
    <script>
        window.MathJax = {
          tex: {
            inlineMath: [['$', '$'], ['\\(', '\\)']],
            displayMath: [['$$', '$$'], ['\\[', '\\]']]
          },
          svg: {
            fontCache: 'global'
          }
        };
    </script>
    <script type="text/javascript" id="MathJax-script" async
      src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js">
    </script>
    
    <style>
        body { font-family: 'Inter', sans-serif; }
        /* 간단한 로딩 스피너 */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 32px;
            height: 32px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* 캔버스 스타일 */
        canvas {
            touch-action: none; /* 모바일에서 그릴 때 페이지 스크롤 방지 */
            width: 100%;
            height: auto;
        }
        /* 활성 도구 스타일 */
        .tool-btn.active {
            @apply ring-2 ring-blue-500 bg-blue-100;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen flex items-center justify-center p-4">
    
    <div id="app" class="w-full max-w-3xl mx-auto bg-white rounded-2xl shadow-xl p-6 md:p-10 space-y-8">
        
        <header class="text-center">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">AI 수학 튜터</h1>
            <p class="text-gray-600 mt-2">AI가 출제한 수학 문제를 풀고, 필기 답안을 제출하여 피드백을 받아보세요.</p>
        </header>

        <!-- API 키 입력 -->
        <div class="space-y-2">
            <label for="apiKey" class="block font-medium text-gray-700">Google AI API Key:</label>
            <input type="password" id="apiKey" v-model="apiKey" placeholder="여기에 API 키를 입력하세요"
                   class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition">
            <p class="text-sm text-gray-500">API 키는 브라우저에만 저장되며 서버로 전송되지 않습니다.</p>
        </div>

        <!-- 1. 문제 출제 섹션 -->
        <section class="space-y-4">
            <h2 class="text-2xl font-semibold text-gray-800 border-b pb-2">1. 오늘의 문제</h2>

            <!-- 문제 유형 및 난이도 입력 -->
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div>
                    <label for="problemType" class="block font-medium text-gray-700">문제 유형:</label>
                    <input type="text" id="problemType" v-model="problemType" placeholder="예: 미적분, 이차함수..."
                           class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition">
                </div>
                <div>
                    <label for="difficulty" class="block font-medium text-gray-700">난이도 (1-5):</label>
                    <select id="difficulty" v-model.number="difficultyLevel"
                            class="w-full px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:outline-none transition bg-white">
                        <option value="1">1 (쉬움)</option>
                        <option value="2">2</option>
                        <option value="3">3 (보통)</option>
                        <option value="4">4</option>
                        <option value="5">5 (어려움)</option>
                    </select>
                </div>
            </div>

            <div class="flex justify-center">
                <button @click="getMathProblem" :disabled="isLoadingProblem || !apiKey"
                        class="px-6 py-2 bg-green-600 text-white font-semibold rounded-lg shadow-md hover:bg-green-700 transition-all duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    <span v-if="!isLoadingProblem">새로운 문제 받기</span>
                    <span v-else class="flex items-center space-x-2">
                        <span class="loader !w-5 !h-5 !border-2 !border-t-white"></span>
                        <span>출제 중...</span>
                    </span>
                </button>
            </div>
            
            <div v-if="mathProblem" 
                 id="math-problem-display"
                 class="p-6 bg-gray-50 border border-gray-200 rounded-lg shadow-inner min-h-[100px] text-lg text-gray-800"
                 v-html="mathProblem">
                <!-- v-html을 사용하여 LaTeX 렌더링을 준비. 내용은 watch에서 처리 -->
            </div>
            <div v-if="!mathProblem && !isLoadingProblem" class="text-center text-gray-500 p-4">
                버튼을 눌러 수학 문제를 받아보세요.
            </div>
        </section>

        <!-- 2. 답안 제출 섹션 (캔버스) -->
        <section class="space-y-4">
            <h2 class="text-2xl font-semibold text-gray-800 border-b pb-2">2. 답안 필기</h2>
            <p class="text-gray-600">아래 영역에 풀이 과정을 직접 필기하세요. (PC/모바일/태블릿 지원)</p>
            
            <!-- 캔버스 도구 모음 -->
            <div class="flex flex-wrap gap-2 justify-center p-2 bg-gray-100 rounded-lg">
                <button @click="setTool('pen-black')" class="tool-btn px-4 py-2 rounded-lg" :class="{'active': currentTool === 'pen-black'}">
                    펜 (검정)
                </button>
                <button @click="setTool('pen-red')" class="tool-btn px-4 py-2 rounded-lg" :class="{'active': currentTool === 'pen-red'}">
                    펜 (빨강)
                </button>
                <button @click="setTool('eraser')" class="tool-btn px-4 py-2 rounded-lg" :class="{'active': currentTool === 'eraser'}">
                    지우개
                </button>
                <button @click="clearCanvas" class="px-4 py-2 bg-red-500 text-white rounded-lg hover:bg-red-600 transition-colors">
                    전체 삭제
                </button>
                <button @click="increaseHeight" class="px-4 py-2 bg-yellow-500 text-white rounded-lg hover:bg-yellow-600 transition-colors">
                    필기 영역 늘리기
                </button>
            </div>

            <!-- 캔버스 -->
            <div class="border-2 border-gray-300 rounded-lg overflow-hidden">
                <canvas 
                    ref="canvasRef"
                    :width="canvasWidth"
                    :height="canvasHeight"
                    class="bg-white"
                    @mousedown="startDrawing"
                    @mousemove="draw"
                    @mouseup="stopDrawing"
                    @mouseout="stopDrawing"
                    @touchstart.prevent="startDrawing"
                    @touchmove.prevent="draw"
                    @touchend="stopDrawing"
                ></canvas>
            </div>
        </section>

        <!-- 3. 피드백 받기 섹션 -->
        <section class="space-y-4">
            <h2 class="text-2xl font-semibold text-gray-800 border-b pb-2">3. AI 피드백</h2>
            <div class="flex justify-center">
                <button @click="getFeedback" :disabled="isLoadingFeedback || !mathProblem || !apiKey"
                        class="px-6 py-2 bg-blue-600 text-white font-semibold rounded-lg shadow-md hover:bg-blue-700 transition-all duration-200 disabled:bg-gray-400 disabled:cursor-not-allowed">
                    <span v-if="!isLoadingFeedback">피드백 받기</span>
                    <span v-else class="flex items-center space-x-2">
                        <span class="loader !w-5 !h-5 !border-2 !border-t-white"></span>
                        <span>분석 중...</span>
                    </span>
                </button>
            </div>

            <div v-if="feedback" 
                 id="feedback-display"
                 class="p-6 bg-blue-50 border border-blue-200 rounded-lg shadow-inner min-h-[100px]"
                 v-html="feedback">
                 <!-- v-html을 사용하여 LaTeX 렌더링을 준비. 내용은 watch에서 처리 -->
            </div>
            <div v-if="!feedback && !isLoadingFeedback" class="text-center text-gray-500 p-4">
                답안을 제출하고 피드백을 받아보세요.
            </div>
        </section>

        <!-- 에러 메시지 -->
        <div v-if="error" class="p-4 bg-red-100 border border-red-300 text-red-800 rounded-lg shadow">
            <h4 class="font-bold">오류 발생:</h4>
            <p class="whitespace-pre-wrap">{{ error }}</p>
        </div>

    </div>

    <script type="module">
        const { createApp, ref, onMounted, nextTick, watch } = Vue; // 'watch' 추가

        createApp({
            setup() {
                // 상태 변수들
                const apiKey = ref('');
                const mathProblem = ref('');
                const feedback = ref('');
                const isLoadingProblem = ref(false);
                const isLoadingFeedback = ref(false);
                const error = ref('');

                // 문제 출제 옵션
                const problemType = ref('고등 미적분'); // 기본값
                const difficultyLevel = ref(3); // 기본값

                // 캔버스 관련 상태
                const canvasRef = ref(null);
                const ctxRef = ref(null);
                const isDrawing = ref(false);
                const canvasWidth = ref(700); // 캔버스 내부 해상도 너비
                const canvasHeight = ref(400); // 캔버스 내부 해상도 높이 (반응형으로 증가)
                const currentTool = ref('pen-black');
                const lastPos = ref({ x: 0, y: 0 });

                // Gemini API 기본 URL
                const API_URL_BASE = "https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=";

                // 캔버스 초기화
                onMounted(() => {
                    const canvas = canvasRef.value;
                    if (!canvas) return;

                    // 캔버스 해상도를 부모 너비에 맞게 설정 (스타일은 100%로 조절됨)
                    const containerWidth = canvas.parentElement.clientWidth;
                    canvasWidth.value = containerWidth > 0 ? containerWidth : 700;
                    
                    ctxRef.value = canvas.getContext('2d');
                    ctxRef.value.lineCap = 'round';
                    ctxRef.value.lineJoin = 'round';
                    setTool('pen-black'); // 기본 도구 설정
                });

                // MathJax 렌더링을 위한 헬퍼 함수
                function renderMath(elementId) {
                    nextTick(() => {
                        const element = document.getElementById(elementId);
                        if (element && window.MathJax) {
                            window.MathJax.typesetClear([element]);
                            window.MathJax.typesetPromise([element]).catch((err) => console.log('MathJax Typeset Error:', err));
                        }
                    });
                }

                // mathProblem이 변경될 때마다 MathJax 렌더링 실행
                watch(mathProblem, () => {
                    renderMath('math-problem-display');
                });

                // feedback이 변경될 때마다 MathJax 렌더링 실행
                watch(feedback, () => {
                    renderMath('feedback-display');
                });


                /**
                 * API 호출을 위한 fetch 함수 (지수 백오프 포함)
                 */
                async function fetchWithRetry(url, options, maxRetries = 3) {
                    let attempt = 0;
                    while (attempt < maxRetries) {
                        try {
                            const response = await fetch(url, options);
                            if (!response.ok) {
                                const errorData = await response.json();
                                throw new Error(`HTTP error! status: ${response.status}, message: ${errorData.error?.message || response.statusText}`);
                            }
                            return await response.json();
                        } catch (err) {
                            attempt++;
                            if (attempt >= maxRetries) {
                                throw err;
                            }
                            const delay = Math.pow(2, attempt) * 1000 + Math.random() * 1000; // 2s, 4s, 8s...
                            await new Promise(resolve => setTimeout(resolve, delay));
                        }
                    }
                }

                /**
                 * 1. 수학 문제 받아오기
                 */
                async function getMathProblem() {
                    if (!apiKey.value) {
                        error.value = "API 키를 먼저 입력해주세요.";
                        return;
                    }
                    isLoadingProblem.value = true;
                    error.value = '';
                    feedback.value = '';
                    clearCanvas(); // 새 문제 받으면 캔버스 초기화
                    canvasHeight.value = 400; // 캔버스 높이도 초기화

                    // 사용자가 요청한 유형과 난이도를 바탕으로 프롬프트 생성
                    const userPrompt = `고등학생 수준의 수학 문제를 하나 출제해 주세요.
- 주제: ${problemType.value}
- 난이도: ${difficultyLevel.value} (1=가장 쉬움, 5=가장 어려움)

문제만 간결하게 제시해 주세요. (별다른 설명 없이 문제 자체만)
**중요: 모든 수학 수식, 변수, 공식은 반드시 LaTeX 형식을 사용해 주세요. 예: $f(x) = x^2 + 1$, $$ \int_{a}^{b} x \,dx $$**`;

                    const payload = {
                        contents: [{
                            parts: [{
                                text: userPrompt // 동적으로 생성된 프롬프트 사용
                            }]
                        }],
                        systemInstruction: {
                            parts: [{ text: "당신은 수학 교사입니다. 학생에게 풀 수학 문제를 출제합니다." }]
                        },
                    };

                    try {
                        const result = await fetchWithRetry(API_URL_BASE + apiKey.value, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        
                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text) {
                            // v-html을 사용할 것이므로 기본 텍스트 래핑
                            mathProblem.value = `<p class="text-lg text-gray-800 whitespace-pre-wrap">${text.trim()}</p>`;
                        } else {
                            throw new Error("AI로부터 유효한 응답을 받지 못했습니다. (문제 출제)");
                        }
                    } catch (err) {
                        console.error("Error getting math problem:", err);
                        error.value = `문제 출제 중 오류가 발생했습니다: ${err.message}`;
                    } finally {
                        isLoadingProblem.value = false;
                    }
                }

                // --- 캔버스 로직 ---

                // 캔버스 내 상대 좌표 계산
                function getCanvasPosition(event) {
                    const canvas = canvasRef.value;
                    const rect = canvas.getBoundingClientRect();
                    const scaleX = canvas.width / rect.width;
                    const scaleY = canvas.height / rect.height;

                    let clientX, clientY;
                    if (event.touches && event.touches.length > 0) {
                        clientX = event.touches[0].clientX;
                        clientY = event.touches[0].clientY;
                    } else {
                        clientX = event.clientX;
                        clientY = event.clientY;
                    }

                    return {
                        x: (clientX - rect.left) * scaleX,
                        y: (clientY - rect.top) * scaleY
                    };
                }

                // 그리기 시작
                function startDrawing(event) {
                    if (!ctxRef.value) return;
                    isDrawing.value = true;
                    lastPos.value = getCanvasPosition(event);
                    ctxRef.value.beginPath();
                    ctxRef.value.moveTo(lastPos.value.x, lastPos.value.y);
                }

                // 그리기
                function draw(event) {
                    if (!isDrawing.value) return;
                    const pos = getCanvasPosition(event);
                    ctxRef.value.lineTo(pos.x, pos.y);
                    ctxRef.value.stroke();
                    lastPos.value = pos;
                }

                // 그리기 종료
                function stopDrawing() {
                    if (!isDrawing.value) return;
                    isDrawing.value = false;
                    ctxRef.value.closePath();
                }

                // 캔버스 도구 설정
                function setTool(tool) {
                    currentTool.value = tool;
                    if (!ctxRef.value) return;

                    if (tool === 'pen-black') {
                        ctxRef.value.strokeStyle = 'black';
                        ctxRef.value.lineWidth = 2;
                        ctxRef.value.globalCompositeOperation = 'source-over';
                    } else if (tool === 'pen-red') {
                        ctxRef.value.strokeStyle = 'red';
                        ctxRef.value.lineWidth = 2;
                        ctxRef.value.globalCompositeOperation = 'source-over';
                    } else if (tool === 'eraser') {
                        ctxRef.value.strokeStyle = 'white'; // 배경색으로 지움
                        ctxRef.value.lineWidth = 20;
                        ctxRef.value.globalCompositeOperation = 'destination-out'; // 고급 지우개
                    }
                }

                // 캔버스 지우기
                function clearCanvas() {
                    if (!ctxRef.value) return;
                    ctxRef.value.clearRect(0, 0, canvasWidth.value, canvasHeight.value);
                }

                // 캔버스 높이 늘리기
                async function increaseHeight() {
                    if (!ctxRef.value || !canvasRef.value) return;

                    // 1. 현재 이미지 데이터 백업
                    const imgData = ctxRef.value.getImageData(0, 0, canvasWidth.value, canvasHeight.value);
                    
                    // 2. 캔버스 높이 늘리기
                    canvasHeight.value += 200;

                    // 3. DOM이 업데이트될 때까지 기다림
                    await nextTick();

                    // 4. 백업한 이미지 데이터 복원
                    // 캔버스 컨텍스트가 리셋될 수 있으므로 스타일 다시 적용
                    ctxRef.value.lineCap = 'round';
                    ctxRef.value.lineJoin = 'round';
                    setTool(currentTool.value); 
                    ctxRef.value.putImageData(imgData, 0, 0);
                }


                /**
                 * 3. 피드백 받기 (캔버스 이미지 분석)
                 */
                async function getFeedback() {
                    if (!apiKey.value) {
                        error.value = "API 키를 먼저 입력해주세요.";
                        return;
                    }
                    if (!canvasRef.value) {
                        error.value = "캔버스가 준비되지 않았습니다.";
                        return;
                    }

                    isLoadingFeedback.value = true;
                    error.value = '';

                    // 캔버스 데이터를 Base64로 변환 (PNG)
                    const dataUrl = canvasRef.value.toDataURL("image/png");
                    const base64Data = dataUrl.split(',')[1];

                    if (!base64Data) {
                         error.value = "캔버스 이미지 데이터를 읽을 수 없습니다.";
                         isLoadingFeedback.value = false;
                         return;
                    }

                    const payload = {
                        contents: [
                            {
                                parts: [
                                    { text: `다음 수학 문제에 대한 학생의 필기 풀이입니다:\n\n[문제]:\n${mathProblem.value}\n\n[학생 풀이 이미지]:` },
                                    {
                                        inlineData: {
                                            mimeType: "image/png",
                                            data: base64Data
                                        }
                                    },
                                    { text: `\n\n[요청]:\n학생의 필기 과정을 단계별로 분석해주세요. 만약 틀린 부분이 있다면 명확하게 지적하고, 올바른 풀이 방법이나 힌트를 친절하게 설명해주세요. 잘한 부분이 있다면 칭찬해주세요.\
                                    \n**중요: 피드백에 포함되는 모든 수학 수식, 변수, 공식은 반드시 LaTeX 형식을 사용해 주세요. 예: $f(x) = x^2 + 1$, $$ \int_{a}^{b} x \,dx $$**` }
                                ]
                            }
                        ],
                        systemInstruction: {
                            parts: [{ text: "당신은 친절하고 전문적인 수학 튜터입니다. 학생의 필기 풀이를 채점하고 상세한 피드백을 제공합니다." }]
                        },
                    };

                    try {
                        const result = await fetchWithRetry(API_URL_BASE + apiKey.value, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });

                        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (text) {
                            // v-html을 사용할 것이므로 h3 태그와 p 태그를 직접 주입
                            feedback.value = `<h3 class="text-xl font-semibold text-blue-800 mb-3">AI 튜터의 피드백:</h3>
                                              <p class="text-lg text-gray-800 whitespace-pre-wrap">${text.trim()}</p>`;
                        } else {
                            // content가 없는 경우 (e.g., safety-settings 차단)
                            const finishReason = result.candidates?.[0]?.finishReason;
                            if (finishReason === 'SAFETY') {
                                throw new Error("AI가 안전상의 이유로 응답을 거부했습니다. (이미지가 부적절하거나 정책 위반)");
                            } else {
                                throw new Error(`AI로부터 유효한 응답을 받지 못했습니다. (피드백). Reason: ${finishReason}`);
                            }
                        }
                    } catch (err) {
                        console.error("Error getting feedback:", err);
                        error.value = `피드백 요청 중 오류가 발생했습니다: ${err.message}\n${err.stack.includes("503") ? "서버가 과부하 상태일 수 있습니다. 잠시 후 다시 시도해주세요." : ""}`;
                    } finally {
                        isLoadingFeedback.value = false;
                    }
                }

                return {
                    apiKey,
                    mathProblem,
                    feedback,
                    isLoadingProblem,
                    isLoadingFeedback,
                    error,
                    getMathProblem,
                    getFeedback,

                    // 문제 출제 옵션
                    problemType,
                    difficultyLevel,

                    // 캔버스
                    canvasRef,
                    canvasWidth,
                    canvasHeight,
                    currentTool,
                    startDrawing,
                    draw,
                    stopDrawing,
                    setTool,
                    clearCanvas,
                    increaseHeight
                };
            }
        }).mount('#app');
    </script>

</body>
</html>
